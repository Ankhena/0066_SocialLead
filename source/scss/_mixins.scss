@use "sass:math"; // для подключения модуля math в scss
@use "sass:string"; // для работы со строками

@mixin container {

  width: 100%;
  margin-left: auto;
  margin-right: auto;

  @include _lg {
    //max-width: $lg;
    max-width: 1920px;
    //max-width: clampvw(770, 1948); // чтобы были пропорциональные поля
  }
}

@mixin container-padding {
  padding: {
    left: var(--x-padding);
    right: var(--x-padding);
  }
}

@mixin visually-hidden {
  // до box-suppress самым лаконичным будет это:
  position: fixed;
  transform: scale(0);
}

//vw
$layout-width: 1920; //указываем ширину макета, от которой вычисляем vw

@function vw($size) {
  @return #{(math.div($size, $layout-width)*100)}vw;
}

@function clampvw($min, $max) {
  @return clamp(#{$min}px,  #{(math.div($max, $layout-width)*100)}vw, #{$max}px);
}

// Применение функций vw и clamp
//.dd {
//  font-size: vw(120);
//}
//.dd {
//  font-size: clampvw(18,120);
//}

// функция, которая переведет px в vw
// и в итоге запретит увеличиваться больше, чем было px при макетной ширине
// не нужно будет писать лишние media
// тут используется в основном для padding крупных секций
@function min-px-vw($size) {
  // но нужно экранировать min, т.к. зарезервированная функция scss
  @return #{"min("}$size+px, (math.div($size, $layout-width)*100)+vw#{")"};
}

@mixin ul-reset {
  padding-left: 0;
  list-style-type: none;
}

@mixin centerer($horizontal: true, $vertical: true) {
  position: absolute;

  @if ($horizontal and $vertical) {
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
  } @else if ($horizontal) {
    left: 50%;
    transform: translate(-50%, 0);
  } @else if ($vertical) {
    top: 50%;
    transform: translate(0, -50%);
  }
}

//// Использование
//.both {
//  @include centerer;
//}
//
//.horizontal {
//  @include centerer(true, false);
//}
//
//.vertical {
//  @include centerer(false, true);
//}

//media

@mixin _esm {
  @media (min-width: $esm) {
    @content;
  }
}

@mixin _sm {
  @media (min-width: $sm) {
    @content;
  }
}

@mixin _md {
  @media (min-width: $md) {
    @content;
  }
}

@mixin _lg {
  @media (min-width: $lg) {
    @content;
  }
}

@mixin _elg {
  @media (min-width: $elg) {
    @content;
  }
}

@mixin _lg-max {
  @media (max-width: ($lg - 0.02px)) {
    @content;
  }
}

@mixin _md-max {
  @media (max-width: ($md - 0.02px)) {
    @content;
  }
}

@mixin _sm-max {
  @media (max-width: $sm - 0.02px) {
    @content;
  }
}

@mixin _esm-max {
  @media (max-width: $esm - 0.02px) {
    @content;
  }
}

@function str-replace($string, $search, $replace: "") {
  $index: str-index($string, $search);

  @if $index {
    @return str-slice($string, 1, $index - 1) + $replace + str-replace(str-slice($string, $index + str-length($search)), $search, $replace);
  }

  @return $string;
}

////Usage:
//.selector {
//  $string: 'The answer to life the universe and everything is 42.';
//  content: str-replace($string, 'e', 'xoxo');
//}
////Result:
//.selector {
//  content: "Thxoxo answxoxor to lifxoxo thxoxo univxoxorsxoxo and xoxovxoxorything is 42.";
//}

//Для цвета в SVG
//
//var(--bright): #6dace2;
//$fill: str-replace(var(--bright), '#', '%23');
//в самой svg fill='#{$fill}'


/* stylelint-disable */
@mixin adaptive-bg($image, $ext: ".jpg") {
  background: {

    image: image-set(url($image + "@3x" + $ext) 3x, url($image + "@2x" + $ext) 2x, url($image + $ext) 1x);

    image: image-set(
        url($image + "@3x.webp") type("image/webp") 3x,
        url($image + "@2x.webp") type("image/webp") 2x,
        url($image + ".webp") type("image/webp") 1x,
        url($image + "@3x" + $ext) 3x,
        url($image + "@2x" + $ext) 2x,
        url($image + $ext) 1x
    );
  }
}
/* stylelint-enable */


// Для этой функции нужен @use "sass:string"; в начале файла
@function imageSet--old($file-name) {
  $dot-pos: string.index($file-name, ".");

  @if $dot-pos == null {
    @error "Файл должен содержать расширение, например 'puppy.png'";
  }
  $ext: string.slice($file-name, $dot-pos + 1);
  $base-name: string.slice($file-name, 1, $dot-pos - 1);
  $base-path: "../img/";

  $result: "image-set(url(\"#{$base-path}#{$base-name}@1x.webp\") type(\"image/webp\") 1x, url(\"#{$base-path}#{$base-name}@2x.webp\") type(\"image/webp\") 2x, url(\"#{$base-path}#{$base-name}@1x.#{$ext}\") type(\"image/#{$ext}\") 1x, url(\"#{$base-path}#{$base-name}@2x.#{$ext}\") type(\"image/#{$ext}\") 2x)";

  @return string.unquote($result);
}

// Пример использования
/*
.intro {
  //background: mixins.imageSet("bg.jpg") no-repeat top center / cover;
  background: imageSet("bg.jpg") no-repeat top center / cover;
}
*/

@function imageSet($file-name, $max-density: 2) {
  $dot-pos: string.index($file-name, ".");

  @if $dot-pos == null {
    @error "Файл должен содержать расширение, например 'puppy.png'";
  }

  $ext: string.slice($file-name, $dot-pos + 1);
  $base-name: string.slice($file-name, 1, $dot-pos - 1);
  $base-path: "../img/";

  $parts: ();

  // Добавляем webp версии с нужными плотностями
  @for $i from 1 through $max-density {
    $parts: append($parts, "url(\"#{$base-path}#{$base-name}@#{$i}x.webp\") type(\"image/webp\") #{$i}x");
  }

  // Добавляем исходный формат с нужными плотностями
  @for $i from 1 through $max-density {
    $parts: append($parts, "url(\"#{$base-path}#{$base-name}@#{$i}x.#{$ext}\") type(\"image/#{$ext}\") #{$i}x");
  }

  $result: "image-set(";

  @each $part in $parts {
    $index: index($parts, $part);
    $comma: if($index < length($parts), ",", "");
    // Вставляем каждый элемент как строку с интерполяцией #{} — чтобы не было лишних 'n'
    $result: $result + "  " + "#{$part}" + $comma;
  }

  $result: $result + ")";

  @return string.unquote($result);
}

// Пример использования
// Где 3 это максимальная плотность (может быть 1, 2 или 3)
// .some-class {
//   background-image: imageSet("puppy.png", 3);
// }
